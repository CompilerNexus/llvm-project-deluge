This document outlines a new capability model for Fil-C called InvisiCap. InvisiCap is a possible
replacement for the current Fil-C MonoCap model. The goal of InvisiCap is that it:

- Aims at super fast checks of all int (i.e. non-ptr) accesses. Because int accesses outnumber ptr
  accesses, this should result in a big speed-up.
- Aims at ptr accesses that are no worse than in Fil-C right now (and are possibly better).
- Allows ptr-int unions where you can flip-flop between ptr and int.
    -> Storing an int where there used to be a ptr changes where the ptr points, but retains the old
       capability. So, int stores only result in a valid ptr if the address is in bounds of whatever
       that pointer used to point to.
    -> Storing a ptr where there used to be an int is fine. Future int reads will see the ptr's raw
       value.
  This removes one of the big reasons why Fil-C is currently incompatible with some C code and changes
  are needed to make that C code work in Fil-C.
- Retains atomicity of ptrs so long as they are marked volatile, _Atomic, or std::atomic (just like
  MonoCaps) and there is no atomic int versus atomic ptr type confusion. See bottom of the doc for an
  analysis of atomicity.
- Does not require CAS on stores or loads, except exactly one CAS the first time that a ptr is stored
  into an object. This should be a big speed-up over MonoCaps, which require CAS on first access to
  each word (and this shows up in profiles).
- Gives the illusion of pointers being 64-bit. This removes another compatibility hurdle (lots of code
  just assumes that pointers are either 32-bit or 64-bit and nothing else).
- Does not sacrifice memory safety at all.

InvisiCap introduces a different space trade-off than MonoCap. MonoCaps require 1 byte for every 16
bytes and a 32 byte object header. InvisiCaps require 8 bytes for every 8 bytes in any object that has
at least one pointer, but zero otherwise, plus a 16 byte header. So, InvisiCaps are more efficient for
integer-only objects, more efficient for pointer-only objects, equally efficient for small objects
that mix integers and pointers, and less efficient for large objects that mix integers and pointers.

The capability object precedes the allocation, always. It's:

    struct filc_object {
        size_t size;
        uintptr_t aux; /* High 16 bits hold flags, low 48 bits holds the aux ptr. */
    };

Newly allocated memory always gets a filc_object header, the aux starts out zero, the size is the
object's size (rounded up to 8 bytes), and the payload is always initialized to zero.

Pointers are a tuple of the raw pointer and the lower bound, i.e. the end of the capability object.

So, filc_ptr_lower(ptr) points at the tail end of the filc_object, and that's what the capability
pointer carries. So, to get the filc_ptr_object(ptr), we do ((filc_object*)filc_ptr_lower(ptr)) - 1.

And to support atomics, we have:

    struct PAS_ALIGNED(16) filc_atomic_box {
        void* lower;
        void* ptr;
    };

For normal objects, the object->aux & FILC_AUX_PTR_MASK pointer points at an array of either lowers or
atomic boxes. The aux entries are tagged with FILC_ATOMIC_BOX_BIT (i.e. (uintptr_t)1) to indicate that
the lower points at a filc_atomic_box.

The aux array may not exist (for int-only objects). If it exists, it has exactly the same number of
bytes as the main object. Integers in the object have no corresponding entry in aux (it will be zero).
Pointers in the object will have the raw pointer in the main object and the capability pointer (in the
form of a pointer to the lower bound, i.e. a pointer to the "top" of the filc_object) in the
corresponding entry in aux. Finally, atomic pointers (pointers that were accessed using atomics) will
have a filc_atomic_box pointer in the corresponding entry in aux, and that box will have the
authoritative value of that atomic pointer. But, the pointers value will be non-atomically replicated
into the main object payload, so nonatomic integers loads get *some* value that is reasonably recent.

Aux is created lazily, on first pointer store. Atomic boxes are created lazily, on first atomic
pointer store.

In the case of specials, size is zero, preventing all access. Flags tells what kind of special object
we have.

In the case of function pointers, aux & FILC_AUX_PTR_MASK points to the actual function. In the case
of all other specials, the aux points to wherever we say it's legal for the pointer to point in order
to actually use it.

Pointers at rest always have lower pointing at the tail of a filc_object, and never at an atomic box.

It's still the case that pointers-at-rest have the filc_ptr type, which carries both the lower and the
raw_ptr. But pointers stored in the heap are usually split - the raw_ptr is in the main object payload
while the lower is in the aux.

We rely on the following helpers:

    void* filc_ptr_lower(filc_ptr); /* Returns the lower portion of the ptr. This is zero actual work
                                       since the lower will be carried in a register. */
    filc_object* filc_ptr_object(filc_ptr); /* Returns the filc_object (i.e. lower minus object
                                               size). Also zero actual work, since the compiler will
                                               just generate object accesses as negative offsets to
                                               lower. */
    void* filc_ptr_ptr(filc_ptr); /* The raw pointer. Zero actual work since the raw ptr will be
                                     carried in a register. */
    filc_ptr filc_ptr_create(void* lower, void* raw_ptr); /* Wrap up a lower/raw_ptr into a filc_ptr.
                                                             Zero actual work. */
    void filc_object_make_aux(filc_object*); /* Allocate an aux for the object. Fast inlined object
                                                allocation plus a CAS to set the low 48 bits of aux
                                                without disturbing the flags. The payload of the aux
                                                is always initialized to zero on allocation. */
    char* filc_object_aux_ptr(filc_object*); /* Return the pointer portion of the aux (the low 48
                                                bits). I.e. object->aux & FILC_AUX_PTR_MASK. Returned
                                                as a char* because all uses involve arithmetic in
                                                terms of bytes. */
    void filc_store_barrier(filc_object*); /* Execute a GC store barrier when the value being stored
                                              points at the given object. */
    filc_atomic_box* filc_atomic_box_create(filc_ptr value); /* Allocate an atomic box and initialize
                                                                it to the given ptr. */
    filc_ptr filc_atomic_box_load_atomic(filc_atomic_box*); /* 128-bit atomic load. */
    void filc_atomic_box_store_atomic(filc_atomic_box*, filc_ptr); /* 128-bit atomic store. */

An nonatomic integer read looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    return *(uintptr_t*)filc_ptr_ptr(ptr);

An nonatomic integer write looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_object(ptr)->flags & FILC_OBJECT_FLAG_READONLY)
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    *(uintptr_t*)filc_ptr_ptr(ptr) = new_value;

An atomic integer read looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (filc_object_aux_ptr(filc_ptr_object(ptr)) {
        uintptr_t lower_or_box = *(uintptr_t*)(
            filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr)));
        if ((lower_or_box & FILC_ATOMIC_BOX_BIT))
            return (uintptr_t)((filc_atomic_box*)(lower_or_box & ~FILC_ATOMIC_BOX_BIT)box)->raw_ptr;
    }
    return *(uintptr_t*)filc_ptr_ptr(ptr);

An atomic integer write looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (filc_object_aux_ptr(filc_ptr_object(ptr))) {
        uintptr_t lower_or_box = *(uintptr_t*)(
            filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr)));
        if ((lower_or_box & FILC_ATOMIC_BOX_BIT))
            ((filc_atomic_box*)(lower_or_box & ~FILC_ATOMIC_BOX_BIT))->raw_ptr = (void*)new_value;
    }
    *(uintptr_t*)filc_ptr_ptr(ptr) = new_value;

An atomic integer CAS looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (filc_object_aux_ptr(filc_ptr_object(ptr))) {
        uintptr_t lower_or_box = *(uintptr_t*)(
            filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr)));
        if ((lower_or_box & FILC_ATOMIC_BOX_BIT)) {
            if (CAS(&((filc_atomic_box*)(lower_or_box & ~FILC_ATOMIC_BOX_BIT))->raw_ptr,
                    (void*)expected_value, (void*)new_value)) {
                *(uintptr_t*)filc_ptr_ptr(ptr) = new_value;
                return true;
            } else
                return false;
        }
    }
    return CAS((uintptr_t*)filc_ptr_ptr(ptr), expected_value, new_value);

A pointer read (atomic or not) looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (!filc_object_aux_ptr(filc_ptr_object(ptr)))
        return filc_ptr_create(NULL, *(void**)filc_ptr_ptr(ptr));
    uintptr_t lower_or_box = *(uintptr_t*)(
        filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr)));
    if ((lower_or_box & FILC_ATOMIC_BOX_BIT)) {
        return filc_atomic_box_load_atomic(
            (filc_atomic_box*)(lower_or_box & ~FILC_ATOMIC_BOX_BIT)box);
    }
    return filc_ptr_create((void*)lower_or_box, *(void**)filc_ptr_ptr(ptr));

A nonatomic pointer write looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_object(ptr)->flags & FILC_OBJECT_FLAG_READONLY)
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (!filc_object_aux_ptr(filc_ptr_object(ptr)))
        filc_object_make_aux(filc_ptr_object(ptr));
    filc_store_barrier(filc_ptr_object(new_value));
    *(void**)(filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr))) =
        filc_ptr_lower(new_value);
    *(void**)filc_ptr_ptr(ptr) = filc_ptr_ptr(new_value);

An atomic pointer write looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_object(ptr)->flags & FILC_OBJECT_FLAG_READONLY)
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (!filc_object_aux_ptr(filc_ptr_object(ptr)))
        filc_object_make_aux(filc_ptr_object(ptr));
    filc_store_barrier(filc_ptr_object(new_value));
    uintptr_t* lower_or_box_ptr = (uintptr_t*)(
        filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr)));
    uintptr_t lower_or_box = *lower_or_box_ptr;
    if ((lower_or_box & FILC_ATOMIC_BOX_BIT)) {
        filc_atomic_box_store_atomic(
            (filc_atomic_box*)(lower_or_box & ~FILC_ATOMIC_BOX_BIT), new_value);
    } else {
        *lower_or_box_ptr = (uintptr_t)filc_atomic_box_create(new_value) | FILC_ATOMIC_BOX_BIT;
    *(void**)filc_ptr_ptr(ptr) = filc_ptr_ptr(new_value);

An atomic pointer CAS looks like:

    if (misaligned)
        fail;
    if (!filc_ptr_lower(ptr))
        fail;
    if (filc_ptr_object(ptr)->flags & FILC_OBJECT_FLAG_READONLY)
        fail;
    if (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr) >= filc_ptr_object(ptr)->size)
        fail;
    if (!filc_object_aux_ptr(filc_ptr_object(ptr)))
        filc_object_make_aux(filc_ptr_object(ptr));
    filc_store_barrier(filc_ptr_object(new_value));
    uintptr_t* lower_or_box_ptr = (uintptr_t*)(
        filc_object_aux_ptr(filc_ptr_object(ptr)) + (filc_ptr_ptr(ptr) - filc_ptr_lower(ptr)));
    for (;;) {
        uintptr_t lower_or_box = *lower_or_box_ptr;
        bool cas_successful;
        if ((lower_or_box & FILC_ATOMIC_BOX_BIT)) {
            cas_successful = filc_atomic_box_cas_atomic(
                (filc_atomic_box*)(lower_or_box & ~FILC_ATOMIC_BOX_BIT), expected_value, new_value);
        } else if ((void*)lower_or_box == filc_ptr_lower(expected_value) &&
                   *(void**)filc_ptr_ptr(ptr) == filc_ptr_ptr(expected_value)) {
            if (!CAS(lower_or_box_ptr, lower_or_box,
                     (uintptr_t)filc_atomic_box_create(new_value) | FILC_ATOMIC_BOX_BIT))
                continue;
            cas_successful = true;
        } else
            cas_successful = false;
        *(void**)filc_ptr_ptr(ptr) = filc_ptr_ptr(new_value);
        return cas_successful;
    }

Note that the CAS algorithms are guaranteed to linearize if certain conditions are met:

- There's no int-ptr type confusion. Int-ptr type confusion could cause CAS to not be linear, so you
  might get time travel and races.
- Ptr fields are marked volatile, _Atomic, or std::atomic.

Integer CAS linearizes even if the field is not marked volatile, _Atomic, or std::atomic, but isn't
guaranteed to linearize if the same field is also used for pointer CAS. That said, integer CAS does
linearize even for pointer fields provided that the field was used for a pointer atomic access before
any integer atomic access. But if there's a race between an integer CAS on a field and the first ever
pointer CAS on that field, then the CASes fail to be atomic.

Pointer CAS is guaranteed to linearize if the field has only ever been used with pointer atomic
accesses. But there are exceptions where it'll still linearize even if that's not the case:

- As soon as a ptr field is used for an atomic store or atomic CAS, all subsequent integer atomic
  accesses and all subsequent pointer accesses (atomic or not) will linearize. So it's valid to, for
  example, make a ptr field atomic by doing an atomic store of NULL right after allocation and then
  have all subsequent loads/stores not be atomic.
- If a field is initialized using non-atomic stores (or is left in its initial NULL state after
  allocaction) but all subsequent stores and CASes are atomic, then accesses to the field linearize.

To summarize, atomics really are atomic - for both integers and pointers - so long as there's no
int-ptr type confusion and atomically accessed ptr fields are marked volatile, _Atomic, or
std::atomic. If there is int-ptr type confusion or atomic loads/stores to ptrs not marked atomic, then
those accesses might still be atomic provided that a more subtle set of rules is followed.

