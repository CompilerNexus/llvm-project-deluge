#!/usr/bin/env ruby
#
# Copyright (c) 2023-2024 Epic Games, Inc. All Rights Reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY EPIC GAMES, INC. ``AS IS AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL EPIC GAMES, INC. OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

require 'etc'
require 'pathname'
require 'shellwords'
require 'yaml'
require 'fileutils'
require 'getoptlong'

$runTests = true
$verbose = false
$filter = /./
$specificTest = nil

$compilerPrefix = ""
$bundleOpt = "-shared"
$dylibOpt = "-shared"
$dylibExt = ".so"
$libraryPathEnv = "LD_LIBRARY_PATH"
$make = "make"
$pizfix = "pizfix"

GetoptLong.new(
    [ '--no-run', '-n', GetoptLong::NO_ARGUMENT ],
    [ '--verbose', '-v', GetoptLong::NO_ARGUMENT ],
    [ '--filter', '-f', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--test', '-t', GetoptLong::REQUIRED_ARGUMENT ],
    [ '--pizfix', '-p', GetoptLong::REQUIRED_ARGUMENT ],
).each {
    | opt, arg |
    case opt
    when '--no-run'
        $runTests = false
    when '--verbose'
        $verbose = true
    when '--filter'
        $filter = Regexp.new(arg)
    when '--test'
        $specificTest = arg
    when '--pizfix'
        $pizfix = arg
    else
        raise
    end
}

raise unless ARGV.empty?

raise unless system("#{$compilerPrefix}clang -c -o filc/tests/legacy_utils.o filc/tests/legacy_utils.c -Ilibpas/src/libpas -g")
raise unless system("#{$compilerPrefix}#{$pizfix}/../build/bin/clang -O3 -c -o filc/tests/utils.o filc/tests/utils.c -g")

$testDirectory = Pathname.new("filc/tests")
$testOutputDirectory = Pathname.new("filc/test-output")
$testOutputDirectory.mkpath
$testOutputDirectory.rmtree
$testOutputDirectory.mkpath

$tests = []

def handleArray(thing)
    return [] unless thing
    return thing if thing.is_a? Array
    [thing]
end

$testDirectory.each_entry {
    | testName |
    next if testName == Pathname.new(".")
    next if testName == Pathname.new("..")
    next unless testName.to_s =~ $filter
    if $specificTest
        next unless testName.to_s == $specificTest
    end
    fullPath = $testDirectory + testName
    next unless fullPath.directory?
    unless (fullPath + "manifest").exist?
        puts "Skipping #{testName}, no manifest."
        next
    end
    outputPath = $testOutputDirectory + testName
    outputPath.mkpath
    manifest = YAML.load_file(fullPath + "manifest")
    onlyOnPlatform = manifest["only-on-platform"]
    if onlyOnPlatform and RUBY_PLATFORM !~ Regexp.new(onlyOnPlatform)
        if $verbose
            puts "Skipping #{testName}, requires #{onlyOnPlatform}"
        end
        next
    end
    if manifest["skip"] and not $specificTest
        puts "Skipping #{testName}"
        next
    end
    expectedReturn = manifest["return"]
    raise unless expectedReturn == "success" or expectedReturn == "failure" or
        expectedReturn == "crash" or expectedReturn == "compileFailure" or
        expectedReturn == "dontCrash" or expectedReturn == "exit13"
    expectedOutputs = handleArray(manifest["output-includes"])
    forbiddenOutputs = handleArray(manifest["output-excludes"])
    optFlags = manifest["optFlags"]
    unless optFlags
        optFlags = "-O2"
    end
    runScript = outputPath + "run.sh"
    compileScript = outputPath + "compile.sh"
    justRunScript = outputPath + "justRun.sh"
    justRunReleaseScript = outputPath + "justRunRelease.sh"
    subRunScript = outputPath + "subRun.sh"
    subRunScribbleScript = outputPath + "subRunScribble.sh"
    subRunSTWScript = outputPath + "subRunSTW.sh"
    subRunReleaseScript = outputPath + "subRunRelease.sh"
    binary = outputPath + testName
    compilerOutput = outputPath + "compilerOutput.txt"
    output = outputPath + "output.txt"
    outputScribble = outputPath + "outputScribble.txt"
    outputSTW = outputPath + "outputSTW.txt"
    outputRelease = outputPath + "outputRelease.txt"
    File.open(compileScript, "w") {
        | outp |
        outp.puts "#!/bin/sh"
        libraries = manifest["libraries"]
        libraryFiles = {}
        outp.puts "rm -f #{Shellwords.shellescape(compilerOutput)}"
        outp.puts "touch #{Shellwords.shellescape(compilerOutput)}"
        fullPath.each_entry {
            | entry |
            next unless entry.extname == ".c" or entry.extname == ".ll" or entry.extname == ".cpp"
            isCpp = entry.extname == ".cpp"
            if isCpp
                clang = "clang++"
                extraOpts = "-std=c++20"
            else
                clang = "clang"
                extraOpts = ""
            end
            outp.puts "#{$compilerPrefix}#{$pizfix}/../build/bin/#{clang} -c -o #{Shellwords.shellescape(outputPath + entry)}.o #{Shellwords.shellescape(fullPath + entry)} -Ifilc/tests #{optFlags} -g #{extraOpts} >> #{Shellwords.shellescape(compilerOutput)} 2>&1"
            if expectedReturn == "compileFailure"
                outp.puts "if [ $? -eq 0 ]"
                outp.puts "then"
                outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: compiled #{entry} but shouldn't have"))
                outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
                outp.puts "    exit 1"
                outp.puts "fi"
            else
                outp.puts "if [ $? -ne 0 ]"
                outp.puts "then"
                outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: couldn't compile #{entry}"))
                outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
                outp.puts "    exit 1"
                outp.puts "fi"
            end
        }
        break if expectedReturn == "compileFailure"
        if libraries
            libraries.each_pair {
                | libname, data |
                if data["isBundle"]
                    libraryOpt = $bundleOpt
                else
                    libraryOpt = $dylibOpt
                    libname += $dylibExt
                end
                linkerIsCpp = false
                data["files"].each {
                    | entry |
                    linkerIsCpp = true if Pathname.new(entry).extname == ".cpp"
                }
                if linkerIsCpp
                    clangLinker = "clang++"
                else
                    clangLinker = "clang"
                end
                outp.print "#{$compilerPrefix}#{$pizfix}/../build/bin/#{clangLinker} #{libraryOpt} -o #{Shellwords.shellescape(outputPath + libname)}"
                data["files"].each {
                    | file |
                    libraryFiles[file] = true
                    outp.print " #{Shellwords.shellescape(outputPath + file)}.o"
                }
                outp.puts " >> #{Shellwords.shellescape(compilerOutput)} 2>&1"
                outp.puts "if [ $? -ne 0 ]"
                outp.puts "then"
                outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: couldn't link #{libname}"))
                outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
                outp.puts "    exit 1"
                outp.puts "fi"
            }
        end
        linkerIsCpp = false
        fullPath.each_entry {
            | entry |
            next unless entry.extname == ".c" or entry.extname == ".ll" or entry.extname == ".cpp"
            next if libraryFiles[entry.to_s]
            linkerIsCpp = true if entry.extname == ".cpp"
        }
        if linkerIsCpp
            clangLinker = "clang++"
        else
            clangLinker = "clang"
        end
        outp.print "#{$compilerPrefix}#{$pizfix}/../build/bin/#{clangLinker} -o #{Shellwords.shellescape(binary)}"
        fullPath.each_entry {
            | entry |
            next unless entry.extname == ".c" or entry.extname == ".ll" or entry.extname == ".cpp"
            next if libraryFiles[entry.to_s]
            outp.print " #{Shellwords.shellescape(outputPath + entry)}.o"
        }
        if manifest["extraLinkerArgs"]
            outp.print " #{manifest["extraLinkerArgs"]}"
        end
        outp.puts " filc/tests/legacy_utils.o filc/tests/utils.o >> #{Shellwords.shellescape(compilerOutput)} 2>&1"
        outp.puts "if [ $? -ne 0 ]"
        outp.puts "then"
        outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: couldn't link"))
        outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
        outp.puts "    exit 1"
        outp.puts "fi"
    }
    if expectedReturn != "compileFailure"
        File.open(justRunScript, "w") {
            | outp |
            outp.puts "#!/bin/sh"
            outp.puts "set -e"
            outp.print "#{$libraryPathEnv}=#{$pizfix}/lib_test"
            if manifest["extraLDPath"]
                outp.print ":#{manifest["extraLDPath"]}"
            end
            outp.print " "
            handleArray(manifest["extra-env"]).each {
                | entry |
                outp.print "#{entry} "
            }
            outp.puts "#{Shellwords.shellescape(binary)}"
        }
        File.open(justRunReleaseScript, "w") {
            | outp |
            outp.puts "#!/bin/sh"
            outp.puts "set -e"
            if manifest["extraLDPath"]
                outp.print "#{$libraryPathEnv}=#{manifest["extraLDPath"]} "
            end
            handleArray(manifest["extra-env"]).each {
                | entry |
                outp.print "#{entry} "
            }
            outp.puts "#{Shellwords.shellescape(binary)}"
        }
        [{:script => subRunScript,
          :cmdPrefix => "FUGC_RAGE_MODE=1",
          :justRunScript => justRunScript,
          :output => output},
         {:script => subRunScribbleScript,
          :cmdPrefix => "FUGC_RAGE_MODE=1 FUGC_SCRIBBLE=1",
          :justRunScript => justRunScript,
          :output => outputScribble},
         {:script => subRunSTWScript,
          :cmdPrefix => "FUGC_MIN_THRESHOLD=0 FUGC_STW=1",
          :justRunScript => justRunScript,
          :output => outputSTW},
         {:script => subRunReleaseScript,
          :cmdPrefix => "",
          :justRunScript => justRunReleaseScript,
          :output => outputRelease}].each {
            | params |
            File.open(params[:script], "w") {
                | outp |
                outp.puts "#!/bin/sh"
                outp.puts "#{params[:cmdPrefix]} FILC_EXIT_ON_PANIC=1 FILC_DUMP_SETUP=1 #{Shellwords.shellescape(params[:justRunScript])} > #{Shellwords.shellescape(params[:output])} 2>&1"
                case expectedReturn
                when "failure"
                    outp.puts "if [ $? -ne 42 ]"
                when "crash"
                    outp.puts "if [ $? -eq 0 ]"
                when "success"
                    outp.puts "if [ $? -ne 0 ]"
                when "exit13"
                    outp.puts "if [ $? -ne 13 ]"
                when "dontCrash"
                    outp.puts "if [ $? -ne 0 -a $? -ne 42 ]"
                else
                    raise
                end
                outp.puts "then"
                case expectedReturn
                when "failure"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to return failure"))
                when "crash"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to crash"))
                when "success"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to return success"))
                when "exit13"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to return 13"))
                when "dontCrash"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to return success or failure, but not crash"))
                else
                    raise
                end
                outp.puts "    cat #{Shellwords.shellescape(params[:output])}"
                outp.puts "    exit 1"
                outp.puts "fi"
                expectedOutputs.each {
                    | expectedOutput |
                    outp.puts "fgrep #{Shellwords.shellescape(expectedOutput)} #{Shellwords.shellescape(params[:output])} > /dev/null || {"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected output to contain #{expectedOutput}"))
                    outp.puts "    cat #{Shellwords.shellescape(params[:output])}"
                    outp.puts "    exit 1"
                    outp.puts "}"
                }
                forbiddenOutputs.each {
                    | forbiddenOutput |
                    outp.puts "fgrep #{Shellwords.shellescape(forbiddenOutput)} #{Shellwords.shellescape(params[:output])} > /dev/null && {"
                    outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected output to NOT contain #{forbiddenOutput}"))
                    outp.puts "    cat #{Shellwords.shellescape(params[:output])}"
                    outp.puts "    exit 1"
                    outp.puts "}"
                }
                outp.puts ":"
            }
        }
    end
    File.open(runScript, "w") {
        | outp |
        outp.puts "#!/bin/sh"
        outp.puts "set -e"
        outp.puts "#{Shellwords.shellescape(compileScript)}"
        if expectedReturn != "compileFailure"
            subRuns = manifest["subRuns"]
            if not subRuns or subRuns["default"]
                outp.puts "#{Shellwords.shellescape(subRunScript)}"
            end
            if not subRuns or subRuns["scribble"]
                outp.puts "#{Shellwords.shellescape(subRunScribbleScript)}"
            end
            if not subRuns or subRuns["stw"]
                outp.puts "#{Shellwords.shellescape(subRunSTWScript)}"
            end
            if not subRuns or subRuns["release"]
                outp.puts "#{Shellwords.shellescape(subRunReleaseScript)}"
            end
        end
    }
    compileScript.chmod(0755)
    if expectedReturn != "compileFailure"
        justRunScript.chmod(0755)
        justRunReleaseScript.chmod(0755)
        subRunScript.chmod(0755)
        subRunScribbleScript.chmod(0755)
        subRunSTWScript.chmod(0755)
        subRunReleaseScript.chmod(0755)
    end
    runScript.chmod(0755)
    if manifest["slow"]
        $tests.unshift runScript
    else
        $tests << runScript
    end
}

File.open("filc/tests/testmakefile", "w") {
    | outp |
    outp.print "all:"
    $tests.each_with_index {
        | test, index |
        outp.print " .t#{index}"
    }
    outp.puts
    $tests.each_with_index {
        | test, index |
        outp.puts ".t#{index}:"
        if $verbose
            outp.puts "\t@#{Shellwords.shellescape(test)}"
            outp.puts "\t@echo #{test}: success"
        else
            outp.puts "\t@#{Shellwords.shellescape(test)}"
            outp.puts "\t@echo -n ."
        end
    }
}

if $runTests
    raise unless system("#{$make} -k -f filc/tests/testmakefile -j #{Etc.nprocessors}")
    puts "SUCCESS"
end


