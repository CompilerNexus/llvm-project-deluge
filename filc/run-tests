#!/usr/bin/env ruby
#
# Copyright (c) 2023-2024 Epic Games, Inc. All Rights Reserved.
#
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions
# are met:
# 1. Redistributions of source code must retain the above copyright
#    notice, this list of conditions and the following disclaimer.
# 2. Redistributions in binary form must reproduce the above copyright
#    notice, this list of conditions and the following disclaimer in the
#    documentation and/or other materials provided with the distribution.
#
# THIS SOFTWARE IS PROVIDED BY EPIC GAMES, INC. ``AS IS AND ANY
# EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
# IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
# PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL EPIC GAMES, INC. OR
# CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
# PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
# PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
# OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. 

require 'etc'
require 'pathname'
require 'shellwords'
require 'yaml'

if RUBY_PLATFORM =~ /darwin/
    $compilerPrefix = "xcrun "
    $bundleOpt = "-bundle"
    $libraryPathEnv = "DYLD_LIBRARY_PATH"
else
    $compilerPrefix = ""
    $bundleOpt = "-shared"
    $libraryPathEnv = "LD_LIBRARY_PATH"
end

if RUBY_PLATFORM =~ /freebsd/ or RUBY_PLATFORM =~ /openbsd/
    $make = "gmake"
else
    $make = "make"
end

raise unless system("#{$compilerPrefix}clang -c -o filc/tests/legacy_utils.o filc/tests/legacy_utils.c -Ilibpas/src/libpas -g")
raise unless system("#{$compilerPrefix}build/bin/clang -O3 -c -o filc/tests/utils.o filc/tests/utils.c -g")

$testDirectory = Pathname.new("filc/tests")

$tests = []

def handleArray(thing)
    return [] unless thing
    return thing if thing.is_a? Array
    [thing]
end

$testDirectory.each_entry {
    | entry |
    next if entry == Pathname.new(".")
    next if entry == Pathname.new("..")
    testName = entry.basename
    fullPath = $testDirectory + entry
    next unless fullPath.directory?
    unless (fullPath + "manifest").exist?
        puts "Skipping #{entry}, no manifest."
        next
    end
    manifest = YAML.load_file(fullPath + "manifest")
    expectedReturn = manifest["return"]
    raise unless expectedReturn == "success" or expectedReturn == "failure" or expectedReturn == "crash"
    expectedOutputs = handleArray(manifest["output-includes"])
    forbiddenOutputs = handleArray(manifest["output-excludes"])
    runScript = fullPath + "run.sh"
    compileScript = fullPath + "compile.sh"
    justRunScript = fullPath + "justRun.sh"
    justRunReleaseScript = fullPath + "justRunRelease.sh"
    subRunScript = fullPath + "subRun.sh"
    subRunSTWScript = fullPath + "subRunSTW.sh"
    subRunReleaseScript = fullPath + "subRunRelease.sh"
    binary = fullPath + testName
    compilerOutput = fullPath + "compilerOutput.txt"
    output = fullPath + "output.txt"
    outputSTW = fullPath + "outputSTW.txt"
    outputRelease = fullPath + "outputRelease.txt"
    File.open(compileScript, "w") {
        | outp |
        outp.puts "#!/bin/sh"
        libraries = manifest["libraries"]
        libraryFiles = {}
        outp.puts "rm -f #{Shellwords.shellescape(compilerOutput)}"
        outp.puts "touch #{Shellwords.shellescape(compilerOutput)}"
        fullPath.each_entry {
            | entry |
            next unless entry.extname == ".c" or entry.extname == ".ll" or entry.extname == ".cpp"
            isCpp = entry.extname == ".cpp"
            if isCpp
                clang = "clang++"
                extraOpts = "-std=c++20"
            else
                clang = "clang"
                extraOpts = ""
            end
            outp.puts "#{$compilerPrefix}build/bin/#{clang} -c -o #{Shellwords.shellescape(fullPath + entry)}.o #{Shellwords.shellescape(fullPath + entry)} -Ifilc/tests -O2 -g #{extraOpts} >> #{Shellwords.shellescape(compilerOutput)} 2>&1"
            outp.puts "if [ $? -ne 0 ]"
            outp.puts "then"
            outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: couldn't compile #{entry}"))
            outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
            outp.puts "    exit 1"
            outp.puts "fi"
        }      
        if libraries
            libraries.each_pair {
                | libname, files |
                linkerIsCpp = false
                files.each {
                    | entry |
                    linkerIsCpp = true if Pathname.new(entry).extname == ".cpp"
                }
                if linkerIsCpp
                    clangLinker = "clang++"
                else
                    clangLinker = "clang"
                end
                outp.print "#{$compilerPrefix}build/bin/#{clangLinker} #{$bundleOpt} -o #{Shellwords.shellescape(fullPath + libname)}"
                files.each {
                    | file |
                    libraryFiles[file] = true
                    outp.print " #{Shellwords.shellescape(fullPath + file)}.o"
                }
                outp.puts " >> #{Shellwords.shellescape(compilerOutput)} 2>&1"
                outp.puts "if [ $? -ne 0 ]"
                outp.puts "then"
                outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: couldn't link #{libname}"))
                outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
                outp.puts "    exit 1"
                outp.puts "fi"
            }
        end
        linkerIsCpp = false
        fullPath.each_entry {
            | entry |
            next unless entry.extname == ".c" or entry.extname == ".ll" or entry.extname == ".cpp"
            next if libraryFiles[entry.to_s]
            linkerIsCpp = true if entry.extname == ".cpp"
        }
        if linkerIsCpp
            clangLinker = "clang++"
        else
            clangLinker = "clang"
        end
        outp.print "#{$compilerPrefix}build/bin/#{clangLinker} -o #{Shellwords.shellescape(binary)}"
        fullPath.each_entry {
            | entry |
            next unless entry.extname == ".c" or entry.extname == ".ll" or entry.extname == ".cpp"
            next if libraryFiles[entry.to_s]
            outp.print " #{Shellwords.shellescape(fullPath + entry)}.o"
        }
        outp.puts " filc/tests/legacy_utils.o filc/tests/utils.o >> #{Shellwords.shellescape(compilerOutput)} 2>&1"
        outp.puts "if [ $? -ne 0 ]"
        outp.puts "then"
        outp.puts("    echo " + Shellwords.shellescape(runScript.to_s + ": FAIL: couldn't link"))
        outp.puts "    cat #{Shellwords.shellescape(compilerOutput)}"
        outp.puts "    exit 1"
        outp.puts "fi"
    }
    File.open(justRunScript, "w") {
        | outp |
        outp.puts "#!/bin/sh"
        outp.puts "set -e"
        outp.print "#{$libraryPathEnv}=pizfix/lib_test "
        handleArray(manifest["extra-env"]).each {
            | entry |
            outp.print "#{entry} "
        }
        outp.puts "#{Shellwords.shellescape(binary)}"
    }
    File.open(justRunReleaseScript, "w") {
        | outp |
        outp.puts "#!/bin/sh"
        outp.puts "set -e"
        handleArray(manifest["extra-env"]).each {
            | entry |
            outp.print "#{entry} "
        }
        outp.puts "#{Shellwords.shellescape(binary)}"
    }
    [{:script => subRunScript,
      :cmdPrefix => "FUGC_MIN_THRESHOLD=0",
      :justRunScript => justRunScript,
      :output => output},
     {:script => subRunSTWScript,
      :cmdPrefix => "FUGC_MIN_THRESHOLD=0 FUGC_STW=1",
      :justRunScript => justRunScript,
      :output => outputSTW},
     {:script => subRunReleaseScript,
      :cmdPrefix => "",
      :justRunScript => justRunReleaseScript,
      :output => outputRelease}].each {
        | params |
        File.open(params[:script], "w") {
            | outp |
            outp.puts "#!/bin/sh"
            outp.puts "#{params[:cmdPrefix]} FILC_EXIT_ON_PANIC=1 FILC_DUMP_SETUP=1 #{Shellwords.shellescape(params[:justRunScript])} > #{Shellwords.shellescape(params[:output])} 2>&1"
            case expectedReturn
            when "failure"
                outp.puts "if [ $? -ne 42 ]"
            when "crash"
                outp.puts "if [ $? -eq 0 ]"
            when "success"
                outp.puts "if [ $? -ne 0 ]"
            else
                raise
            end
            outp.puts "then"
            case expectedReturn
            when "failure"
                outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to return failure"))
            when "crash"
                outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to crash"))
            when "success"
                outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected program to return success"))
            else
                raise
            end
            outp.puts "    cat #{Shellwords.shellescape(params[:output])}"
            outp.puts "    exit 1"
            outp.puts "fi"
            expectedOutputs.each {
                | expectedOutput |
                outp.puts "fgrep #{Shellwords.shellescape(expectedOutput)} #{Shellwords.shellescape(params[:output])} > /dev/null || {"
                outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected output to contain #{expectedOutput}"))
                outp.puts "    cat #{Shellwords.shellescape(params[:output])}"
                outp.puts "    exit 1"
                outp.puts "}"
            }
            forbiddenOutputs.each {
                | forbiddenOutput |
                outp.puts "fgrep #{Shellwords.shellescape(forbiddenOutput)} #{Shellwords.shellescape(params[:output])} > /dev/null && {"
                outp.puts("    echo " + Shellwords.shellescape(params[:script].to_s + ": FAIL: expected output to NOT contain #{forbiddenOutput}"))
                outp.puts "    cat #{Shellwords.shellescape(params[:output])}"
                outp.puts "    exit 1"
                outp.puts "}"
            }
            outp.puts ":"
        }
    }
    File.open(runScript, "w") {
        | outp |
        outp.puts "#!/bin/sh"
        outp.puts "set -e"
        outp.puts "#{Shellwords.shellescape(compileScript)}"
        outp.puts "#{Shellwords.shellescape(subRunScript)}"
        outp.puts "#{Shellwords.shellescape(subRunSTWScript)}"
        outp.puts "#{Shellwords.shellescape(subRunReleaseScript)}"
    }
    compileScript.chmod(0755)
    justRunScript.chmod(0755)
    justRunReleaseScript.chmod(0755)
    subRunScript.chmod(0755)
    subRunSTWScript.chmod(0755)
    subRunReleaseScript.chmod(0755)
    runScript.chmod(0755)
    $tests << runScript
}

File.open("filc/tests/testmakefile", "w") {
    | outp |
    outp.print "all:"
    $tests.each_with_index {
        | test, index |
        outp.print " .t#{index}"
    }
    outp.puts
    $tests.each_with_index {
        | test, index |
        outp.puts ".t#{index}:"
        outp.puts "\t@#{Shellwords.shellescape(test)}"
        outp.puts "\t@echo -n ."
    }
}

raise unless system("#{$make} -f filc/tests/testmakefile -j #{Etc.nprocessors}")
puts "SUCCESS"

